use super::*;
use std::collections::HashSet;

pub struct Blockchain {
	pub blocks: Vec<Block>,
	unspent_outputs: HashSet<BlockHash>,
	difficulty: u128,
}

#[derive(Debug)]
pub enum BlockValidationErr {
	MismatchedIndex,
	InvalidHash,
	AchronologicalTimestamp,
	MismatchedPreviousHash,
	InvalidGenesisBlockFormat,
	InvalidInput,
	InsufficientInputValue,
	InvalidCoinbaseTransaction,
	InvalidDifficultyUpdate,
	InvalidTransactionTimestamp
}

impl Blockchain {
	pub fn new () -> Self {
		Blockchain {
			blocks: vec![],
			unspent_outputs: HashSet::new(),
			difficulty: 23, // this value must be updated immediatelty after  
		}
	}

	pub fn new_with_diff (diff: u128) -> Self {
		Blockchain {
			blocks: vec![],
			unspent_outputs: HashSet::new(),
			difficulty: diff, // this value must be updated immediatelty after  
		}
	}

	pub fn update_difficulty (&mut self, diff:u128) -> Result<(), BlockValidationErr> {
		if self.difficulty < diff{
			return Err(BlockValidationErr::InvalidDifficultyUpdate);
		}
		else{
			self.difficulty = diff;
			Ok(())
		}

	}

	pub fn get_difficulty (&self) -> u128 {
		self.difficulty
	}

	pub fn update_with_block (&mut self, block:Block) -> Result<(), BlockValidationErr> {
		let i = self.blocks.len();
		// block index test
		if block.index != i as u32 {
			return Err(BlockValidationErr::MismatchedIndex);
		}
		// failed prescribed difficulty value...should make sure block is storing valid difficulty tho
		else if !block::check_blockhash(&block.hash(), self.difficulty) {
			return Err(BlockValidationErr::InvalidHash);
		}
		else if i != 0{
			// not genesis block
			let prev_block = &self.blocks[i-1];
			if block.timestamp <= prev_block.timestamp {
				return Err(BlockValidationErr::AchronologicalTimestamp);
			}
			else if block.prev_block_hash != prev_block.hash {
				return Err(BlockValidationErr::MismatchedPreviousHash);
			}
		}
		else{
			// genesis block
			if block.prev_block_hash != vec![0; 32] {
				return Err(BlockValidationErr::InvalidGenesisBlockFormat);
			}
		}

		if let Some((coinbase, transactions)) = block.transactions.split_first() {
			if !coinbase.is_coinbase() {
				return Err(BlockValidationErr::InvalidCoinbaseTransaction);
			}

			let mut block_spent:HashSet<BlockHash> = HashSet::new(); // input hashes that were spent in this block
			let mut block_created:HashSet<BlockHash> = HashSet::new(); // (unspent) output hashes generated by this block
			let mut total_fee = 0.0;

			for transaction in transactions {
				let input_hashes = transaction.input_hashes();

				// first condition is if there is a leftover input that didn't come from unspent output
				// second condition is that there is an input hash that has been used twice
				if !(&input_hashes - &self.unspent_outputs).is_empty() || !(&input_hashes & &block_spent).is_empty(){
					return Err(BlockValidationErr::InvalidInput);
				}

				let inputs = &transaction.inputs;
				let outputs = &transaction.outputs;

				for output in outputs {
					let out_time = &output.timestamp; // time of output
					for input in inputs {
						let in_time = &input.timestamp;

						if out_time < in_time {
							// this is an error, you should have already gotten the input stuff before you can output it somewhere else
							return Err(BlockValidationErr::InvalidTransactionTimestamp);
						}
					}
				}

				let input_sum = transaction.input_sum();
				let output_sum = transaction.output_sum();

				if output_sum > input_sum {
					return Err(BlockValidationErr::InsufficientInputValue);
				}

				let fee = input_sum - output_sum;
				total_fee += fee;

				block_spent.extend(input_hashes);
				block_created.extend(transaction.output_hashes())
			}

			if coinbase.output_sum() < total_fee {
				return Err(BlockValidationErr::InvalidCoinbaseTransaction);
			}
			else{
				block_created.extend(coinbase.output_hashes());
			}

			self.unspent_outputs.retain(|output| !block_spent.contains(output));
			self.unspent_outputs.extend(block_created);

		}

		self.blocks.push(block);

		Ok(())
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use crate::transaction::Output;

	fn create_output(addr: &str, value: f64, timestamp: u128) -> Output {
		Output {
			to_addr: addr.to_string(),
			value,
			timestamp,
		}
	}

	#[test]
	fn test_blockchain_creation() {
		let blockchain = Blockchain::new();
		assert_eq!(blockchain.blocks.len(), 0);
		assert_eq!(blockchain.get_difficulty(), 23);
	}

	#[test]
	fn test_blockchain_creation_with_difficulty() {
		let blockchain = Blockchain::new_with_diff(100);
		assert_eq!(blockchain.blocks.len(), 0);
		assert_eq!(blockchain.get_difficulty(), 100);
	}

	#[test]
	fn test_blockchain_get_difficulty() {
		let blockchain = Blockchain::new_with_diff(42);
		assert_eq!(blockchain.get_difficulty(), 42);
	}

	#[test]
	fn test_blockchain_update_difficulty_valid() {
		let mut blockchain = Blockchain::new_with_diff(100);
		let result = blockchain.update_difficulty(50);
		assert!(result.is_ok());
		assert_eq!(blockchain.get_difficulty(), 50);
	}

	#[test]
	fn test_blockchain_update_difficulty_invalid() {
		let mut blockchain = Blockchain::new_with_diff(100);
		let result = blockchain.update_difficulty(150);
		assert!(result.is_err());
		assert_eq!(blockchain.get_difficulty(), 100); // Should remain unchanged
	}

	#[test]
	fn test_blockchain_update_difficulty_equal() {
		let mut blockchain = Blockchain::new_with_diff(100);
		let result = blockchain.update_difficulty(100);
		assert!(result.is_ok());
		assert_eq!(blockchain.get_difficulty(), 100);
	}

	#[test]
	fn test_blockchain_genesis_block_valid() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};

		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase]);
		genesis.mine(u128::MAX);

		let result = blockchain.update_with_block(genesis);
		assert!(result.is_ok());
		assert_eq!(blockchain.blocks.len(), 1);
	}

	#[test]
	fn test_blockchain_genesis_block_invalid_prev_hash() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};

		let mut genesis = Block::new(0, 1000, vec![1; 32], vec![coinbase]);
		genesis.mine(u128::MAX);

		let result = blockchain.update_with_block(genesis);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_block_mismatched_index() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};

		// Create block with index 1 instead of 0
		let mut block = Block::new(1, 1000, vec![0; 32], vec![coinbase]);
		block.mine(u128::MAX);

		let result = blockchain.update_with_block(block);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_block_invalid_hash_difficulty() {
		let mut blockchain = Blockchain::new_with_diff(1); // Very hard difficulty

		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};

		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase]);
		genesis.mine(u128::MAX); // Mine with easy difficulty

		// Block won't pass the harder difficulty check
		let result = blockchain.update_with_block(genesis);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_achronological_timestamp() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Add genesis block
		let coinbase1 = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};
		let mut genesis = Block::new(0, 2000, vec![0; 32], vec![coinbase1]);
		genesis.mine(u128::MAX);
		blockchain.update_with_block(genesis.clone()).unwrap();

		// Try to add block with earlier timestamp
		let coinbase2 = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Charlie", 1.5, 1500),
				create_output("Dave", 0.5, 1500),
			],
		};
		let mut block2 = Block::new(1, 1500, genesis.hash.clone(), vec![coinbase2]);
		block2.mine(u128::MAX);

		let result = blockchain.update_with_block(block2);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_mismatched_previous_hash() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Add genesis block
		let coinbase1 = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};
		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase1]);
		genesis.mine(u128::MAX);
		blockchain.update_with_block(genesis.clone()).unwrap();

		// Try to add block with wrong previous hash
		let coinbase2 = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Charlie", 1.5, 2000),
				create_output("Dave", 0.5, 2000),
			],
		};
		let mut block2 = Block::new(1, 2000, vec![1; 32], vec![coinbase2]);
		block2.mine(u128::MAX);

		let result = blockchain.update_with_block(block2);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_missing_coinbase_transaction() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Create block with no transactions
		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![]);
		genesis.mine(u128::MAX);

		let result = blockchain.update_with_block(genesis);
		// Should succeed because split_first returns None and we skip validation
		assert!(result.is_ok());
	}

	#[test]
	fn test_blockchain_invalid_coinbase_transaction() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Create coinbase with inputs (invalid)
		let invalid_coinbase = Transaction {
			inputs: vec![create_output("Miner", 1.0, 999)],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};

		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![invalid_coinbase]);
		genesis.mine(u128::MAX);

		let result = blockchain.update_with_block(genesis);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_transaction_invalid_input() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Add genesis block
		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};
		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase]);
		genesis.mine(u128::MAX);
		blockchain.update_with_block(genesis.clone()).unwrap();

		// Try to spend an output that doesn't exist
		let coinbase2 = Transaction {
			inputs: vec![],
			outputs: vec![create_output("Miner", 2.0, 2000)],
		};
		let fake_input = create_output("Fake", 10.0, 1500);
		let invalid_tx = Transaction {
			inputs: vec![fake_input],
			outputs: vec![create_output("Charlie", 5.0, 2001)],
		};
		let mut block2 = Block::new(1, 2000, genesis.hash.clone(), vec![coinbase2, invalid_tx]);
		block2.mine(u128::MAX);

		let result = blockchain.update_with_block(block2);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_transaction_insufficient_input_value() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Add genesis block
		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};
		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase.clone()]);
		genesis.mine(u128::MAX);
		blockchain.update_with_block(genesis.clone()).unwrap();

		// Try to spend more than inputs
		let coinbase2 = Transaction {
			inputs: vec![],
			outputs: vec![create_output("Miner", 2.0, 2000)],
		};
		let alice_output = coinbase.outputs[0].clone();
		let invalid_tx = Transaction {
			inputs: vec![alice_output], // Only 1.5
			outputs: vec![create_output("Charlie", 2.0, 2001)], // Trying to spend 2.0
		};
		let mut block2 = Block::new(1, 2000, genesis.hash.clone(), vec![coinbase2, invalid_tx]);
		block2.mine(u128::MAX);

		let result = blockchain.update_with_block(block2);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_transaction_invalid_timestamp() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Add genesis block
		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};
		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase.clone()]);
		genesis.mine(u128::MAX);
		blockchain.update_with_block(genesis.clone()).unwrap();

		// Create transaction with output timestamp before input timestamp
		let coinbase2 = Transaction {
			inputs: vec![],
			outputs: vec![create_output("Miner", 2.0, 2000)],
		};
		let alice_output = coinbase.outputs[0].clone(); // timestamp 1000
		let invalid_tx = Transaction {
			inputs: vec![alice_output],
			outputs: vec![create_output("Charlie", 1.5, 500)], // timestamp 500 < 1000
		};
		let mut block2 = Block::new(1, 2000, genesis.hash.clone(), vec![coinbase2, invalid_tx]);
		block2.mine(u128::MAX);

		let result = blockchain.update_with_block(block2);
		assert!(result.is_err());
	}

	#[test]
	fn test_blockchain_valid_transaction_chain() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Add genesis block
		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};
		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase.clone()]);
		genesis.mine(u128::MAX);
		blockchain.update_with_block(genesis.clone()).unwrap();

		// Create valid transaction spending Alice's output
		let coinbase2 = Transaction {
			inputs: vec![],
			outputs: vec![create_output("Miner", 2.0, 2000)],
		};
		let alice_output = coinbase.outputs[0].clone();
		let valid_tx = Transaction {
			inputs: vec![alice_output],
			outputs: vec![create_output("Charlie", 1.4, 2001)],
		};
		let mut block2 = Block::new(1, 2000, genesis.hash.clone(), vec![coinbase2, valid_tx]);
		block2.mine(u128::MAX);

		let result = blockchain.update_with_block(block2);
		assert!(result.is_ok());
		assert_eq!(blockchain.blocks.len(), 2);
	}

	#[test]
	fn test_blockchain_utxo_tracking() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Add genesis block
		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};
		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase.clone()]);
		genesis.mine(u128::MAX);
		blockchain.update_with_block(genesis.clone()).unwrap();

		// Spend Alice's output
		let coinbase2 = Transaction {
			inputs: vec![],
			outputs: vec![create_output("Miner", 2.0, 2000)],
		};
		let alice_output = coinbase.outputs[0].clone();
		let tx1 = Transaction {
			inputs: vec![alice_output.clone()],
			outputs: vec![create_output("Charlie", 1.4, 2001)],
		};
		let mut block2 = Block::new(1, 2000, genesis.hash.clone(), vec![coinbase2, tx1]);
		block2.mine(u128::MAX);
		blockchain.update_with_block(block2.clone()).unwrap();

		// Try to double-spend Alice's output
		let coinbase3 = Transaction {
			inputs: vec![],
			outputs: vec![create_output("Miner", 2.0, 3000)],
		};
		let tx2 = Transaction {
			inputs: vec![alice_output], // Already spent
			outputs: vec![create_output("Dave", 1.4, 3001)],
		};
		let mut block3 = Block::new(2, 3000, block2.hash.clone(), vec![coinbase3, tx2]);
		block3.mine(u128::MAX);

		let result = blockchain.update_with_block(block3);
		assert!(result.is_err()); // Should fail because output is already spent
	}

	#[test]
	fn test_blockchain_coinbase_with_fees() {
		let mut blockchain = Blockchain::new_with_diff(u128::MAX);

		// Add genesis block
		let coinbase = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Alice", 1.5, 1000),
				create_output("Bob", 0.5, 1000),
			],
		};
		let mut genesis = Block::new(0, 1000, vec![0; 32], vec![coinbase.clone()]);
		genesis.mine(u128::MAX);
		blockchain.update_with_block(genesis.clone()).unwrap();

		// Create transaction with fee (1.5 input, 1.4 output, 0.1 fee)
		let alice_output = coinbase.outputs[0].clone();
		let tx_with_fee = Transaction {
			inputs: vec![alice_output],
			outputs: vec![create_output("Charlie", 1.4, 2001)],
		};

		// Coinbase can claim the fee
		let coinbase2 = Transaction {
			inputs: vec![],
			outputs: vec![
				create_output("Miner", 1.9, 2000), // 2.0 base - 0.1 (less than fee available)
				create_output("MinerExtra", 0.1, 2000),
			],
		};

		let mut block2 = Block::new(1, 2000, genesis.hash.clone(), vec![coinbase2, tx_with_fee]);
		block2.mine(u128::MAX);

		let result = blockchain.update_with_block(block2);
		assert!(result.is_ok());
	}
}