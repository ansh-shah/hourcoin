use super::*;
use std::collections::HashSet;

pub struct Blockchain {
	pub blocks: Vec<Block>,
	unspent_outputs: HashSet<BlockHash>,
	difficulty: u128,
}

#[derive(Debug)]
pub enum BlockValidationErr {
	MismatchedIndex,
	InvalidHash,
	AchronologicalTimestamp,
	MismatchedPreviousHash,
	InvalidGenesisBlockFormat,
	InvalidInput,
	InsufficientInputValue,
	InvalidCoinbaseTransaction,
	InvalidDifficultyUpdate,
	InvalidTransactionTimestamp
}

impl Blockchain {
	pub fn new () -> Self {
		Blockchain {
			blocks: vec![],
			unspent_outputs: HashSet::new(),
			difficulty: 23, // this value must be updated immediatelty after  
		}
	}

	pub fn new_with_diff (diff: u128) -> Self {
		Blockchain {
			blocks: vec![],
			unspent_outputs: HashSet::new(),
			difficulty: diff, // this value must be updated immediatelty after  
		}
	}

	pub fn update_difficulty (&mut self, diff:u128) -> Result<(), BlockValidationErr> {
		if self.difficulty < diff{
			return Err(BlockValidationErr::InvalidDifficultyUpdate);
		}
		else{
			self.difficulty = diff;
			Ok(())
		}

	}

	pub fn get_difficulty (&self) -> u128 {
		self.difficulty
	}

	pub fn update_with_block (&mut self, block:Block) -> Result<(), BlockValidationErr> {
		let i = self.blocks.len();
		// block index test
		if block.index != i as u32 {
			return Err(BlockValidationErr::MismatchedIndex);
		}
		// failed prescribed difficulty value...should make sure block is storing valid difficulty tho
		else if !block::check_blockhash(&block.hash(), self.difficulty) {
			return Err(BlockValidationErr::InvalidHash);
		}
		else if i != 0{
			// not genesis block
			let prev_block = &self.blocks[i-1];
			if block.timestamp <= prev_block.timestamp {
				return Err(BlockValidationErr::AchronologicalTimestamp);
			}
			else if block.prev_block_hash != prev_block.hash {
				return Err(BlockValidationErr::MismatchedPreviousHash);
			}
		}
		else{
			// genesis block
			if block.prev_block_hash != vec![0; 32] {
				return Err(BlockValidationErr::InvalidGenesisBlockFormat);
			}
		}

		if let Some((coinbase, transactions)) = block.transactions.split_first() {
			if !coinbase.is_coinbase() {
				return Err(BlockValidationErr::InvalidCoinbaseTransaction);
			}

			let mut block_spent:HashSet<BlockHash> = HashSet::new(); // input hashes that were spent in this block
			let mut block_created:HashSet<BlockHash> = HashSet::new(); // (unspent) output hashes generated by this block
			let mut total_fee = 0.0;

			for transaction in transactions {
				let input_hashes = transaction.input_hashes();

				// first condition is if there is a leftover input that didn't come from unspent output
				// second condition is that there is an input hash that has been used twice
				if !(&input_hashes - &self.unspent_outputs).is_empty() || !(&input_hashes & &block_spent).is_empty(){
					return Err(BlockValidationErr::InvalidInput);
				}

				let inputs = &transaction.inputs;
				let outputs = &transaction.outputs;

				for output in outputs {
					let out_time = &output.timestamp; // time of output
					for input in inputs {
						let in_time = &input.timestamp;

						if out_time < in_time {
							// this is an error, you should have already gotten the input stuff before you can output it somewhere else
							return Err(BlockValidationErr::InvalidTransactionTimestamp);
						}
					}
				}

				let input_sum = transaction.input_sum();
				let output_sum = transaction.output_sum();

				if output_sum > input_sum {
					return Err(BlockValidationErr::InsufficientInputValue);
				}

				let fee = input_sum - output_sum;
				total_fee += fee;

				block_spent.extend(input_hashes);
				block_created.extend(transaction.output_hashes())
			}

			if coinbase.output_sum() < total_fee {
				return Err(BlockValidationErr::InvalidCoinbaseTransaction);
			}
			else{
				block_created.extend(coinbase.output_hashes());
			}

			self.unspent_outputs.retain(|output| !block_spent.contains(output));
			self.unspent_outputs.extend(block_created);

		}

		self.blocks.push(block);

		Ok(())
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use crate::transaction::{Transaction, Output};
	use crate::now;

	fn create_coinbase_transaction(value: f64, to_addr: &str, timestamp: u128) -> Transaction {
		Transaction {
			inputs: vec![],
			outputs: vec![Output {
				to_addr: to_addr.to_owned(),
				value,
				timestamp,
			}],
		}
	}

	#[test]
	fn test_blockchain_creation() {
		let blockchain = Blockchain::new();
		assert_eq!(blockchain.blocks.len(), 0);
		assert_eq!(blockchain.get_difficulty(), 23);
	}

	#[test]
	fn test_blockchain_with_custom_difficulty() {
		let custom_diff = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
		let blockchain = Blockchain::new_with_diff(custom_diff);
		assert_eq!(blockchain.get_difficulty(), custom_diff);
	}

	#[test]
	fn test_add_genesis_block() {
		let difficulty = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
		let mut blockchain = Blockchain::new_with_diff(difficulty);

		let mut genesis_block = Block::new(
			0,
			now(),
			vec![0; 32],
			vec![create_coinbase_transaction(2.0, "Alice", now())],
		);
		genesis_block.mine(difficulty);

		assert!(blockchain.update_with_block(genesis_block).is_ok());
		assert_eq!(blockchain.blocks.len(), 1);
	}

	#[test]
	fn test_invalid_genesis_block_prev_hash() {
		let difficulty = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
		let mut blockchain = Blockchain::new_with_diff(difficulty);

		let mut genesis_block = Block::new(
			0,
			now(),
			vec![1; 32], // Invalid prev hash - should be all zeros
			vec![create_coinbase_transaction(2.0, "Alice", now())],
		);
		genesis_block.mine(difficulty);

		assert!(matches!(
			blockchain.update_with_block(genesis_block),
			Err(BlockValidationErr::InvalidGenesisBlockFormat)
		));
	}

	#[test]
	fn test_add_second_block() {
		let difficulty = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
		let mut blockchain = Blockchain::new_with_diff(difficulty);

		let timestamp1 = now();
		let mut genesis_block = Block::new(
			0,
			timestamp1,
			vec![0; 32],
			vec![create_coinbase_transaction(2.0, "Alice", timestamp1)],
		);
		genesis_block.mine(difficulty);
		let genesis_hash = genesis_block.hash.clone();
		blockchain.update_with_block(genesis_block).unwrap();

		// Add second block
		let timestamp2 = timestamp1 + 1000; // Must be later than genesis
		let mut block2 = Block::new(
			1,
			timestamp2,
			genesis_hash,
			vec![create_coinbase_transaction(2.0, "Bob", timestamp2)],
		);
		block2.mine(difficulty);

		assert!(blockchain.update_with_block(block2).is_ok());
		assert_eq!(blockchain.blocks.len(), 2);
	}

	#[test]
	fn test_mismatched_index() {
		let difficulty = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
		let mut blockchain = Blockchain::new_with_diff(difficulty);

		let mut genesis_block = Block::new(
			0,
			now(),
			vec![0; 32],
			vec![create_coinbase_transaction(2.0, "Alice", now())],
		);
		genesis_block.mine(difficulty);
		let genesis_hash = genesis_block.hash.clone();
		blockchain.update_with_block(genesis_block).unwrap();

		// Try to add block with wrong index
		let mut block2 = Block::new(
			5, // Wrong index - should be 1
			now(),
			genesis_hash,
			vec![create_coinbase_transaction(2.0, "Bob", now())],
		);
		block2.mine(difficulty);

		assert!(matches!(
			blockchain.update_with_block(block2),
			Err(BlockValidationErr::MismatchedIndex)
		));
	}

	#[test]
	fn test_achronological_timestamp() {
		let difficulty = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
		let mut blockchain = Blockchain::new_with_diff(difficulty);

		let timestamp = now();
		let mut genesis_block = Block::new(
			0,
			timestamp,
			vec![0; 32],
			vec![create_coinbase_transaction(2.0, "Alice", timestamp)],
		);
		genesis_block.mine(difficulty);
		let genesis_hash = genesis_block.hash.clone();
		blockchain.update_with_block(genesis_block).unwrap();

		// Try to add block with earlier timestamp
		let mut block2 = Block::new(
			1,
			timestamp - 1000, // Earlier timestamp - should fail
			genesis_hash,
			vec![create_coinbase_transaction(2.0, "Bob", timestamp)],
		);
		block2.mine(difficulty);

		assert!(matches!(
			blockchain.update_with_block(block2),
			Err(BlockValidationErr::AchronologicalTimestamp)
		));
	}

	#[test]
	fn test_invalid_coinbase_transaction() {
		let difficulty = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
		let mut blockchain = Blockchain::new_with_diff(difficulty);

		// Genesis block with non-coinbase transaction (wrong value)
		let mut genesis_block = Block::new(
			0,
			now(),
			vec![0; 32],
			vec![create_coinbase_transaction(5.0, "Alice", now())], // Wrong value
		);
		genesis_block.mine(difficulty);

		assert!(matches!(
			blockchain.update_with_block(genesis_block),
			Err(BlockValidationErr::InvalidCoinbaseTransaction)
		));
	}

	#[test]
	fn test_transaction_timestamp_validation() {
		let difficulty = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
		let mut blockchain = Blockchain::new_with_diff(difficulty);

		let timestamp = 1000;
		let mut genesis_block = Block::new(
			0,
			timestamp,
			vec![0; 32],
			vec![create_coinbase_transaction(2.0, "Alice", timestamp)],
		);
		genesis_block.mine(difficulty);
		let genesis_hash = genesis_block.hash.clone();
		let first_output = genesis_block.transactions[0].outputs[0].clone();
		blockchain.update_with_block(genesis_block).unwrap();

		// Try to create transaction with output timestamp before input timestamp
		let mut block2 = Block::new(
			1,
			timestamp + 1000,
			genesis_hash,
			vec![
				create_coinbase_transaction(2.0, "Miner", timestamp + 1000),
				Transaction {
					inputs: vec![first_output.clone()], // timestamp: 1000
					outputs: vec![Output {
						to_addr: "Bob".to_owned(),
						value: 1.5,
						timestamp: 500, // Before input timestamp - should fail
					}],
				},
			],
		);
		block2.mine(difficulty);

		assert!(matches!(
			blockchain.update_with_block(block2),
			Err(BlockValidationErr::InvalidTransactionTimestamp)
		));
	}

	#[test]
	fn test_difficulty_update() {
		let mut blockchain = Blockchain::new_with_diff(100);

		// Can reduce difficulty
		assert!(blockchain.update_difficulty(50).is_ok());
		assert_eq!(blockchain.get_difficulty(), 50);

		// Cannot increase difficulty
		assert!(matches!(
			blockchain.update_difficulty(100),
			Err(BlockValidationErr::InvalidDifficultyUpdate)
		));
	}
}